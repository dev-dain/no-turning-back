# 메모이제이션을 이용한 피보나치 재귀식
from functools import wraps

def memo(func):
  cache = {}

  @wraps(func)
  def wrap(*args):
    if args not in cache:
      cache[args] = func(*args)
    return cache[args]
  return wrap

@memo
def fib(n):
  return 1 if n < 2 else fib(n-1) + fib(n-2) 

n = 35
print(fib(35))


'''
재귀 알고리즘 3법칙
1. 종료되는 부분이 있어야 한다.
2. 상태를 변경하고 종료되는 베이스 케이스로 이동
3. 재귀적으로 자신을 호출
계산 중복이나 하위 문제가 겹치는 경우(피보나치) 반복문이 더 좋을 수도 있음
재귀식은 재귀 함수 실행 시간 설명에 쓰임
T(n) = a * T(g(n)) + f(n)
a는 재귀 호출 수, g(n)은 재귀적으로 풀어야 할 하위 문제의 크기, f(n)은 함수에서 수행되는 추가 작업

동적 계획법(dynamic programming)은 복잡한 문제를 재귀를 통해 간단한 하위 문제로 분류, 단순화해 해결하는 방법. 어떤 문제가 최적 부분 구조와 중복 부분 문제를 가진다면 DP로 해결 가능
최적 부분 구조(optimal substructure)는 답을 구하기 위해 했던 계산을 반복해야 하는 문제 구조. DP는 이 부분 문제를 풀고 결과를 저장한 후 다음 부분 문제를 푸는 과정에서 저장된 결과 사용
메모이제이션(memoization)은 프로그램이 동일한 계산을 반복할 때 이전에 계산한 값을 메모리에 저장해 동일 계산의 반복 수행을 제거해 프로그램 실행 속도를 빠르게 하는 기법
반환 값을 캐싱해 재귀식을 구현할 수 있는데 같은 인수가 2번 이상 호출될 때 결과가 캐시에서 반환되는 메모이제이션 메소드 구현 가능
하지만 동적 계획법과 메모이제이션에는 약간의 차이가 있는데 도표를 그리는 방식(일반적 동적 계획법의 접근 방식)은 상향식이고 메모이제이션(일반적 재귀 함수의 호출 방식)은 하향식. 
'''